import { app, BrowserWindow, dialog, ipcMain, shell } from 'electron';
import path from 'path';
import fs from 'fs';

const VITE_DEV_SERVER_URL = process.env.VITE_DEV_SERVER_URL;

let mainWindow: BrowserWindow | null = null;

function getBuildNumber(): string {
  try {
    const buildNumberPath = path.join(__dirname, '../.build-number');
    if (fs.existsSync(buildNumberPath)) {
      return fs.readFileSync(buildNumberPath, 'utf8').trim() || '1';
    }
  } catch (error) {
    console.error('Error reading build number:', error);
  }
  return '1';
}

interface ThemesDirectoryResult {
  found: boolean;
  path: string | null;
  edition: string | null;
}

function detectAbletonThemesDirectory(): ThemesDirectoryResult {
  const editions = ['Suite', 'Standard', 'Intro', 'Lite'];

  for (const edition of editions) {
    let themesPath: string;

    if (process.platform === 'darwin') {
      themesPath = `/Applications/Ableton Live 12 ${edition}.app/Contents/App-Resources/Themes`;
    } else if (process.platform === 'win32') {
      themesPath = path.join(
        process.env.PROGRAMDATA || 'C:\\ProgramData',
        'Ableton',
        `Live 12 ${edition}`,
        'Resources',
        'Themes'
      );
    } else {
      return { found: false, path: null, edition: null };
    }

    if (fs.existsSync(themesPath)) {
      return { found: true, path: themesPath, edition };
    }
  }

  return { found: false, path: null, edition: null };
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    titleBarStyle: 'hiddenInset',
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  if (VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(VITE_DEV_SERVER_URL);
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(path.join(__dirname, '../dist/index.html'));
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

app.whenReady().then(() => {
  const buildNumber = getBuildNumber();

  // Set up IPC handlers
  ipcMain.handle('get-version', () => app.getVersion());
  ipcMain.handle('get-build-number', () => buildNumber);

  ipcMain.handle('detect-themes-directory', () => {
    return detectAbletonThemesDirectory();
  });

  const APP_SIGNATURE = 'Generated by Ableton Theme Generator';

  ipcMain.handle('list-theme-files', async (_event, dirPath: string) => {
    try {
      if (!fs.existsSync(dirPath)) {
        return [];
      }
      const files = fs.readdirSync(dirPath);
      const themeFiles = files
        .filter(file => file.toLowerCase().endsWith('.ask'))
        .map(file => {
          const filePath = path.join(dirPath, file);
          let createdByApp = false;
          try {
            // Read first 200 bytes to check for signature
            const fd = fs.openSync(filePath, 'r');
            const buffer = Buffer.alloc(200);
            fs.readSync(fd, buffer, 0, 200, 0);
            fs.closeSync(fd);
            createdByApp = buffer.toString('utf8').includes(APP_SIGNATURE);
          } catch {
            // If we can't read the file, assume it's not ours
          }
          return { name: file, createdByApp };
        })
        .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
      return themeFiles;
    } catch (error) {
      console.error('Error listing theme files:', error);
      return [];
    }
  });

  ipcMain.handle('delete-theme-file', async (_event, filePath: string) => {
    try {
      // Safety check: only delete .ask files within the themes directory
      const themesDir = detectAbletonThemesDirectory();
      if (!themesDir.found || !themesDir.path) {
        return { success: false, error: 'Themes directory not found' };
      }
      const normalizedPath = path.normalize(filePath);
      const normalizedThemesDir = path.normalize(themesDir.path);
      if (!normalizedPath.startsWith(normalizedThemesDir) || !normalizedPath.endsWith('.ask')) {
        return { success: false, error: 'Invalid file path' };
      }

      // Verify it's a file we created
      const buffer = Buffer.alloc(200);
      const fd = fs.openSync(filePath, 'r');
      fs.readSync(fd, buffer, 0, 200, 0);
      fs.closeSync(fd);
      if (!buffer.toString('utf8').includes(APP_SIGNATURE)) {
        return { success: false, error: 'Cannot delete themes not created by this app' };
      }

      fs.unlinkSync(filePath);
      return { success: true };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  });

  ipcMain.handle('open-path-in-explorer', async (_event, dirPath: string) => {
    const errorMessage = await shell.openPath(dirPath);
    return { success: errorMessage === '', error: errorMessage || null };
  });

  ipcMain.handle('read-image-as-data-url', async (_event, filePath: string) => {
    try {
      const data = fs.readFileSync(filePath);
      const ext = path.extname(filePath).toLowerCase();
      const mimeType = ext === '.png' ? 'image/png' : 'image/jpeg';
      return `data:${mimeType};base64,${data.toString('base64')}`;
    } catch (error) {
      console.error('Error reading image:', error);
      return null;
    }
  });

  ipcMain.handle('open-file-dialog', async () => {
    const prefs = loadPreferences();
    const defaultPath = prefs.lastImageDir || app.getPath('pictures');

    const result = await dialog.showOpenDialog({
      defaultPath,
      properties: ['openFile'],
      filters: [
        { name: 'Images', extensions: ['png', 'jpg', 'jpeg'] },
      ],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }

    const filePath = result.filePaths[0];
    const fileName = path.basename(filePath);

    // Remember this directory for next time
    savePreferences({ ...prefs, lastImageDir: path.dirname(filePath) });

    return { filePath, fileName };
  });

  ipcMain.handle('save-theme-file', async (_event, xmlContent: string, defaultFileName: string) => {
    // Detect Ableton themes directory for default save location
    const themesDir = detectAbletonThemesDirectory();

    const result = await dialog.showSaveDialog({
      title: 'Save Ableton Theme',
      defaultPath: themesDir.found && themesDir.path
        ? path.join(themesDir.path, defaultFileName)
        : defaultFileName,
      filters: [
        { name: 'Ableton Theme', extensions: ['ask'] },
      ],
    });

    if (result.canceled || !result.filePath) {
      return { success: false, filePath: null, error: null };
    }

    try {
      fs.writeFileSync(result.filePath, xmlContent, 'utf8');
      return { success: true, filePath: result.filePath, error: null };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, filePath: null, error: errorMessage };
    }
  });

  // Theme library persistence
  const themeLibraryPath = path.join(app.getPath('userData'), 'theme-library.json');

  // User preferences persistence
  const preferencesPath = path.join(app.getPath('userData'), 'preferences.json');

  function loadPreferences(): { lastImageDir?: string } {
    try {
      if (fs.existsSync(preferencesPath)) {
        return JSON.parse(fs.readFileSync(preferencesPath, 'utf8'));
      }
    } catch (error) {
      console.error('Error loading preferences:', error);
    }
    return {};
  }

  function savePreferences(prefs: { lastImageDir?: string }) {
    try {
      fs.writeFileSync(preferencesPath, JSON.stringify(prefs, null, 2), 'utf8');
    } catch (error) {
      console.error('Error saving preferences:', error);
    }
  }

  ipcMain.handle('load-theme-library', async () => {
    try {
      if (fs.existsSync(themeLibraryPath)) {
        const data = fs.readFileSync(themeLibraryPath, 'utf8');
        return JSON.parse(data);
      }
    } catch (error) {
      console.error('Error loading theme library:', error);
    }
    return { version: 1, themes: [] };
  });

  ipcMain.handle('save-theme-library', async (_event, library: unknown) => {
    try {
      fs.writeFileSync(themeLibraryPath, JSON.stringify(library, null, 2), 'utf8');
      return { success: true };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  });

  // Copy theme file to Downloads folder
  ipcMain.handle('copy-theme-to-downloads', async (_event, sourcePath: string, fileName: string) => {
    try {
      if (!fs.existsSync(sourcePath)) {
        return { success: false, error: 'Source file not found' };
      }
      const downloadsPath = app.getPath('downloads');
      let destPath = path.join(downloadsPath, fileName);

      // Handle name collision by appending number
      let counter = 1;
      const ext = path.extname(fileName);
      const baseName = path.basename(fileName, ext);
      while (fs.existsSync(destPath)) {
        destPath = path.join(downloadsPath, `${baseName} (${counter})${ext}`);
        counter++;
      }

      fs.copyFileSync(sourcePath, destPath);
      return { success: true, destPath };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  });

  // Rename theme file
  ipcMain.handle('rename-theme-file', async (_event, oldPath: string, newPath: string) => {
    try {
      if (!fs.existsSync(oldPath)) {
        return { success: false, error: 'File not found' };
      }
      if (fs.existsSync(newPath)) {
        return { success: false, error: 'A theme with that name already exists' };
      }
      fs.renameSync(oldPath, newPath);
      return { success: true, newPath };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  });

  createWindow();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
